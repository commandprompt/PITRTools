#!/usr/bin/env python

""" LICENSE

Copyright Command Prompt, Inc.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written agreement
is hereby granted, provided that the above copyright notice and this
paragraph and the following two paragraphs appear in all copies.

IN NO EVENT SHALL THE COMMAND PROMPT, INC. BE LIABLE TO ANY PARTY FOR
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
EVEN IF THE COMMAND PROMPT, INC. HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

THE COMMAND PROMPT, INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN
"AS IS" BASIS, AND THE COMMAND PROMPT, INC. HAS NO OBLIGATIONS TO
PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

"""

# $Id$

import os
import re
import sys
import subprocess
from cmd_worker import CMDWorker

argslist = (('-F', '--file', dict(dest="archivefilename",
                action="store", help="Archive file", metavar="FILE")),
               ("-C", "--config", dict(dest="configfilename",
                action="store",  help="the name of the archiver config file",
                metavar="FILE", default='cmd_archiver.ini')),
               ("-I", "--init", dict(dest="init", action="store_true",
                help="Initialize master environment")))

classdict = (('state', 's', None),
            ('rsync_flags', 's', ""),
            ('slaves', 's', None),
            ('user', 's', None),
            ('r_archivedir', 's', None),
            ('l_archivedir', 's', None),
            ('ssh_timeout', 'i', None),
            ('notify_ok', 's', None),
            ('notify_warning', 's', None),
            ('notify_critical', 's', None),
            ('debug', 'b', False),
            ('pgdata', 's', None),
            ('pgcontroldata', 's', ""),
            ('rsync_version', 'i', None),
            ('includepath', 's', None),
            ('ssh_debug', 'b', False))


class ArchiveFailure(Exception):
    """ Class to propagate archiving failures """
    pass


class CMDArchiver(CMDWorker):

    def generate_slave_list_func(self):
        """
        We now support multiple slaves (see the README) in order do that properly
        we have to break up the string and turn it into a list
        """
        slaves = str(self.slaves).replace("'", "").split(",")
        self.debuglog("generate_slave_list_func(): slaves = %s" % slaves)
        return slaves

    def init_env_func(self):
        """
        Initialize the local queues so we can check each directory for left
        over files
        """
        self.debuglog("init_env_func(): entered")
        l_archivedir = self.l_archivedir
        # bail out if archivedir exists and not empty or inaccessible.
        if (os.access(l_archivedir, os.F_OK)):
            if (not os.access(l_archivedir, os.R_OK | os.W_OK | os.X_OK)):
                self.log("init_env_func(): l_archivedir %s must allow have r/w/x bits set for the current user" % l_archivedir, "ERROR")
                return False
            elif (os.listdir(l_archivedir) != []):
                self.log("init_env_func(): l_archivedir %s must be be empty" % l_archivedir, "ERROR")
                return False
            else:
                self.log("init_env_func(): l_archivedir %s already exists" % l_archivedir, "WARNING")
        queues = self.generate_slave_list_func()
        try:
            for host in queues:
                queue = os.path.join(l_archivedir, host)
                os.makedirs("%s" % (queue))
        except OSError, e:
            self.log("init_env_func(): Can not make queue directories", "ERROR")
            print "EXCEPTION: %s" % (str(e))
            exit(1)

    def check_config_func(self):
        """
        Let's make sure that our directories and executables exist
        """
        self.cmd_queue = os.path.join(self.pitr_bin_path, "cmd_queue")
        pathvars = [self.pgdata, self.l_archivedir, self.cmd_queue]
        for element in pathvars:
            try:
                os.stat("%s" % (str(element)))
            except OSError, e:
                print "Config %s:  %s" % (str(element), str(e))
                return False
        if not os.access(self.cmd_queue, os.X_OK):
            self.log("The cmd_queue file must have executable flag set.")
            return False
        return True

    def get_pgcontroldata_func(self):
        """
        get_pgcontroldata_func doesn't actually do anything yet. This is more
        for archival purposes so we can remember the regex
        """
        if not self.pgcontroldata:
            print 'WARNING: path to pg_controldata utility is not set, assuming it\'s in PATH'
            pgcontroldata = 'pg_controldata'
        else:
            pgcontroldata = self.pgcontroldata
        try:
            cmd = os.popen("%s %s" % (str(pgcontroldata), str(self.pgdata)))
            #return cmd.readlines
            for row in cmd:
                match = re.search('^Prior checkpoint location: *.{1,}', '%s' % (str(row)))
                if match != None:
                    print match
        except OSError, e:
            self.log("get_pgcontroldata_func(): %s" % e, "ERROR")
            exit(1)

    def archive_func(self):
        self.log("Archiving %s" % self.archivefile)

        if self.state != "online":
            self.notify_external(log=True, warning=True, message="cmd_archiver offline, queuing archives")
            return False

        try:
            # It is tempting to just hardlink it, but we need to make
            # at least one full copy since postgres might want to
            # recycle the WAL file at the same inode.  The cmd_queue
            # will establish hardlinks to individual slave subdirs,
            # thus no extra space is taken by the WAL queue.
            self.debuglog("copying %s to %s/" % (self.archivefile, self.l_archivedir))
            import shutil
            shutil.copy(os.path.join(self.pgdata, self.archivefile),
                        os.path.join(self.l_archivedir, ""))

            # We call cmd_queue every time and let it figure itself if
            # there's a copy running already.  In case there is none,
            # the daemon flag comes handy.
            cmd_queue = [self.cmd_queue, "-C", self.configfilename,
                         "--daemon"]
            self.debuglog("running cmd_queue as: %s" % repr(cmd_queue))
            ret = subprocess.call(cmd_queue)
            if ret != 0:
                self.notify_external(log=True, critical=True, message=("cmd_queue returned error status: %d" % ret))
                return False
            return True
        except Exception, e:
            self.notify_external(log=True, critical=True, message=("Failed to archive file '%s': %s" % (self.archivefile, e)))
            return False


if __name__ == '__main__':

    # before we do anything, let's just check you we are
    if os.geteuid() == 0:
        sys.exit("\nBad Mojo... no root access for this script\n")

    archiver = CMDArchiver(classdict)
    (options, args) = archiver.parse_commandline_arguments(argslist)
    archiver.configfilename = options.configfilename
    init = options.init

    archiver.archivefile = options.archivefilename

    try:
        cfg_vals = archiver.load_configuration_file(archiver.configfilename)
    except Exception, e:
        archiver.log(e, "ERROR")
        exit(2)

    archiver.set_ssh_flags()

    success = True
    # Actually run
    if init:
        print "We are initializing queues, one moment.\n"
        success = archiver.init_env_func()
    else:
        archiver.debuglog("Archiver running")
        #Get binary paths and check config values
        archiver.get_bin_paths_func(options)
        success = archiver.check_config_func()
        if success:
            if archiver.archivefile:
                try:
                    success = archiver.archive_func()
                except:
                    success = False
                    print archiver.pull_exception()
            else:
                print "Config OK.  Use -F FILE to actually archive one."
                success = False  # in case this was put into production

    archiver.debuglog("Archiver exiting with status %d" % (0 if success else 1))
    if success:
        sys.exit(0)
    else:
        sys.exit(1)
